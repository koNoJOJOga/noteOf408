# 文件系统

## 引言

&emsp;&emsp;&ensp;在学习文件系统之前，我们需要先理解一个最基础的概念：文件。那么文件是什么？文件系统又是什么？从不同视角来看，文件与文件系统似乎有不同的的解释。

### 存放位置

&emsp;&emsp;&ensp;从存放位置的角度来看，文件是**存放在磁盘中的数据信息集合**，文件系统对应着整个磁盘中的所有的文件。在本课程中，我们称**存放在磁盘中的真正的文件数据为文件实体**。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 64.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 用户视角

&emsp;&emsp;&ensp;用户视角下，文件系统是一棵文件树。文件树上的每一个节点对应一个文件。任何文件都对应一条从 ${root}$ 开始的绝对路径。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 65.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 66.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;文件元数据：文件元数据是**文件全部属性信息的集合**。一个文件在磁盘中**既拥有文件实体，也存放了文件元数据**。操作系统只有获取了文件元数据并将其读入内存，才能对文件实体进行访问。在 ${UNIX}$ 文件系统中，文件元数据被保存在一种名为索引节点（${inode}$）的结构中，${inode}$ 以 ${inode}$ 表（数组）的形式被组织在磁盘固定区域。因此，只需要给出**文件索引节点在表中的编号**，便可以取出对应的索引节点，**并对文件进行操作**。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 67.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 68.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;用户视角下的文件是**连续的**，用户访问文件的方式是使用**文件的逻辑地址**，${inode}$ 中包含可以将**文件逻辑地址转化为磁盘物理地址的信息**。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 69.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 文件系统功能

### 目录系统

&emsp;&emsp;&ensp;根据前文所说，想要访问或操作文件需要先找到对应的 ${inode}$，即确定文件对应的 ${inode}$ 编号，因此，我们需要实现的第一个功能即为**根据路径获取文件的 ${inode}$ 编号从而获取其存放在 ${inode}$ 中的元数据**。实现这部分文件系统功能的子系统称为**目录系统**。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 70.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件实现

&emsp;&emsp;&ensp;${inode}$ 中是如何保存文件相关的所有信息尤其是文件数据在磁盘中的位置？文件元数据是如何组织和抽象文件实体的物理位置和保存其他文件相关信息的？这是文件系统需要关注的第二个问题。实现这部分文件系统功能的子系统被称为**文件实现**。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 71.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 进程访问机制

&emsp;&emsp;&ensp;文件是保存在磁盘中的稳定的信息集合，但是操作文件内容的实体却是进程。进程想要访问文件，需要操作系统先将文件元数据放入内存，但是若是多进程访问同一文件，则既需要考虑放入内存的**文件元数据的共享**，也需要考虑每个进程有不同的访问特点，这是文件系统需要解决的问题。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 72.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 文件系统视角下的磁盘空间

&emsp;&emsp;&ensp;文件系统是**以块为单位对磁盘进行访问**的。在文件系统的视角下，磁盘被划分为了**等大的磁盘块**，通过磁盘块号可以定位到磁盘对应的物理位置。同时，**文件内容也以等大的文件（真题有时也称为簇）为基本单位存放在磁盘块中**。一次磁盘 ${I/O}$ 对应内存与磁盘一个块的数据交换。 

<div style=" margin: 0 auto; max-width: 50%;">
<img src="截屏2024-08-25 14.57.25.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;在没有磁盘缓冲的情况下，修改块 ${x}$ 的内容可能需要两次 ${I/O}$（读入内存，在内存中修改，写回磁盘）。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 73.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 磁盘缓存技术

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%AD%98%E5%9C%A8%E5%88%99%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 逻辑文件与物理文件

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 75.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%9A.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 77.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;文件逻辑地址 = 逻辑块号 + 块内偏移
&emsp;&emsp;&ensp;物理逻辑地址 = 物理块号 + 块内偏移
&emsp;&emsp;&ensp;只需要找到**文件元数据**就可以实现逻辑文件向物理文件的转换。

## 目录系统

### 引入

&emsp;&emsp;&ensp;这里简单展示了某文件系统中文件之间的组织关系，如果每一个节点对应一个文件，那么这棵树中一共有几种类型的文件？

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 78.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 目录系统相关的几组概念

#### 目录系统

&emsp;&emsp;&ensp;目录项：目录项描述该目录下的文件信息，包含文件在该目录下的文件名以及该文件名对应的索引节点号。
&emsp;&emsp;&ensp;目录：是一个特殊的文件，它包含一组目录项。
&emsp;&emsp;&ensp;根目录：本文件系统的最上一层目录，索引节点编号一般已知。
&emsp;&emsp;&ensp;绝对路径：某文件项相对根目录的路径。

#### 目录项与目录

&emsp;&emsp;&ensp;目录项：目录项是一种特殊的数据结构，它包含文件名和索引节点编号两个属性值，每个目录项都指向一个对应的索引节点。因此，只要找到文件对应的目录项，即可获取其 ${inode}$，其中 ${inode}$ 表保存于磁盘之中。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 79.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;某些题目中会使用文件控制块 ${FCB}$ 这种说法，实际上它是 ${inode}$ 的一种等价替换。目录项中包含 ${inode}$ 编号，从而去 ${inode}$ 表中可以找到对应的文件元数据，而 ${FCB}$ 则直接集成了文件元数据，**少了一步查找元数据的过程（访问磁盘）**，但是浪费内存（${FCB}$ 占用内存空间远大于目录项结构）。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="截屏2024-08-25 15.56.26.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 目录

&emsp;&emsp;&ensp;目录是一种特殊的文件，包含一组目录项（也是保存在磁盘当中的）。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="inode%E7%BC%96%E5%8F%B7%EF%BC%89.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;目录树的节点实际上是一个个目录项，每个目录项均**对应一个索引节点和文件实体**。
&emsp;&emsp;&ensp;注意：**目录也是文件，其本身也有目录项对应**。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 82.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;根目录：根目录即图中 ${root}$ 所对应的目录，它是整棵目录树的根节点。文件系统在启动时便已经知道了根节点的 ${inode}$ 编号，因此可以直接访问根目录的内容。在很多题目中，根目录可能已经放入了内存。

<div style=" margin: 0 auto; max-width: 30%;">
<img src="root%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;绝对路径：绝对路径即**文件相对于根节点的路径**，例如图中绿色节点的绝对路径为：${root/dir1/dir4/c.av}$

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 83.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 目录检索（核心功能）

&emsp;&emsp;&ensp;目录检索即根据文件的路径获取对应的文件目录项，是为访问文件做铺垫的一个操作。例如，根据路径 ${root/dir1/dir4/c.av}$
获取对应的目录项。
&emsp;&emsp;&ensp;具体过程：

1. 分析路径：${root/dir1/dir4/c.av}$
2. 我们知道，我们需要依次检索 ${4}$ 个文件名 ${root、dir1、dir4、c.av}$。其中，${root}$ 无需检索，我们可以直接获取其 ${inode}$ 编号并访问其内容。
3. 我们需要在 ${root}$ 目录中检索文件名为 ${dir1}$ 的目录项，找到后根据其 ${inode}$ 编号获取其文件元数据并找到其内容。
4. 我们需要在 ${root}$ 目录中检索文件名为 ${dir1}$ 的目录项，找到后根据其 ${inode}$ 编号获取其**文件元数据**，并检索其文件内容中文件名为 ${dir4}$ 的目录项。
5. 最后，我们从 ${dir4}$ 中检索文件名为 ${c.av}$ 的目录项，即完成了目录检索过程。

&emsp;&emsp;&ensp;**如果将 ${c.av}$ 目录项加载进内存，需要读几个文件**？
&emsp;&emsp;&ensp;${3}$ 个，读入 ${dir4}$ 时已经将 ${c.av}$ 读入了。

### 软链接与硬链接

&emsp;&emsp;&ensp;注意：软链接与硬链接均是**对某一个目录项的拷贝，自身也是目录项**。

#### 文件共享

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E7%A3%81%E7%9B%98%E4%BF%A1%E6%81%AF%EF%BC%9Arootxy.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E8%AE%BF%E9%97%AE%E6%97%A0%E6%95%88%E6%96%87%E4%BB%B6%EF%BC%8C%E8%AE%BF%E9%97%AE%E5%A4%B1%E8%B4%A5.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件复制

&emsp;&emsp;&ensp;如果问软链接的链接计数数该看什么？
&emsp;&emsp;&ensp;看软链接直接对应的那个 ${inode}$ 的链接计数数，当软链接被创建的时候，链接计数为 ${1}$，**与其链接文件的本来的链接计数没有关联**。
&emsp;&emsp;&ensp;硬链接创建时候则会在链接文件的 ${inode}$ 链接计数数的基础上 ${+1}$，且此时全体硬链接的链接计数数都会保持一致。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 86.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 87.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 88.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 目录结构与实现

#### 目录结构

&emsp;&emsp;&ensp;单级目录结构：只有一个根目录文件和目录表，所有文件均占有一个目录项且同级。
&emsp;&emsp;&ensp;二级目录结构：为每个用户分配一个目录。
&emsp;&emsp;&ensp;树形目录结构：目录结构呈现为树型，无环、跨边和前向边。
&emsp;&emsp;&ensp;无环图目录结构：目录结构为无环图状，**可能出现跨边和前向边，对应软链接和硬链接**。
&emsp;&emsp;&ensp;目录的实现：目录是目录项组成的集合，最常见操作是按文件名进行检索，存在插入、删除和修改（修改索引节点编号、文件名等）操作。基于这个特点，我们需要考虑使用合适的数据结构来组织一个目录下的所有目录项，来提升目录操作的整体性能。

#### 实现方法

&emsp;&emsp;&ensp;线性表法

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 89.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;散列法（或哈希法）：哈希法所获取的地址 ${n}$，是目录项在文件中的逻辑地址还是目录项在磁盘中的物理地址？
&emsp;&emsp;&ensp;逻辑地址。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="a%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B9.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;${trie}$ 树

<div style=" margin: 0 auto; max-width: 50%;">
<img src="a%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B9-1.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;思维拓展：
&emsp;&emsp;&ensp;本质：在一个字符串集合中寻找匹配的字符串的问题。

<div style=" margin: 0 auto; max-width: 20%;">
<img src="a%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E9%A1%B9-2.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 文件操作

### 文件打开

&emsp;&emsp;&ensp;文件操作的主体是进程，进程**通过系统调用对文件进行访问和操作**。各进程访问文件前必须**先获取对应文件的元数据**，即将对应文件的 ${inode}$ 放入内存中，并告知进程存放位置，这便是文件打开的内容。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 93.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;对于多进程访问同一文件而言，我们实际上只需要加载一个 ${inode}$ 进入内存供多进程共享使用就可以了。然而，各个进程对文件所进行的操作以及操作阶段均有可能不同，因此我们还需要为每个进程创建独立的结构来管理各进程对文件的访问。

&emsp;&emsp;&ensp;索引节点的加载：索引节点**存放在外存的索引节点表**中，进程通过目录检索可以获取文件的目录项并据此**将其从磁盘中载入内存**。索引节点中存放着文件的元数据，除了我们前面提及的物理地址和链接计数字段外，还包含一些其它信息。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 95.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;当索引节点被加载到内存的内核专用缓存区的时候，需要增加一些属性以便操作系统使用。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="截屏2024-08-26 16.21.38.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 97.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;系统级打开文件表：在某些系统的设计中，设计者不希望在内存 ${inode}$ 中加入太多信息使其过于冗余，便建立一张系统级的打开文件表，**每个表项对应一个已经打开的文件（即 ${inode}$ 已经装入内存）**，表项中保存了对应 ${inode}$ 的内存位置及其他附加信息。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;在此设计中，访问计数等信息便存在了系统级打开文件表的表项中，内核缓冲区**仅仅保存单纯的外存inode信息**。
&emsp;&emsp;&ensp;进程级打开文件表：各进程虽然可以共享已经装入内存的 ${inode}$（或者说系统级打开文件表），但是每个进程**对于文件的访问可能有模式、访问速度等各方面的差异**，为了记录每个进程关于文件的不同访问状态，操作系统为每个进程创建了一张进程级打开文件表（又名**文件描述符表，题目中有时候也叫用户级打开文件表**），进程的**打开文件表的位置被记录在进程 ${PCB}$ 中**。
&emsp;&emsp;&ensp;${使用fd访问进程级打开文件表的表项\to 找到系统级打开文件表的表项\to}$ ${找到磁盘中的inode（若系统中没有打开文件表，则直接到这一步）\to 找到文件}$

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6fd.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;具体操作：

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%AF%B9%E5%BA%94%E5%86%85%E5%AD%98inode.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件关闭

&emsp;&emsp;&ensp;具体操作：

<div style=" margin: 0 auto; max-width: 50%;">
<img src="close%EF%BC%88%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9Afd%EF%BC%89.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 带系统级打开文件表的文件打开和关闭

&emsp;&emsp;&ensp;${inode}$ 中访问计数等信息放入了系统级打开文件表，表项增加与移除时机与前面一种设计中内存 ${inode}$ 载入/失效时机相同。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 打开文件的共享与继承

&emsp;&emsp;&ensp;在前面的章节中，我们把打开文件作为进程的一种资源，正是因为**进程拥有进程级打开文件表，进程才能拥有对文件的操作能力**。
&emsp;&emsp;&ensp;同一进程的不同线程共享打开文件表，因此每一个线程都可以用**相同的文件描述符访问到相同的文件**。
&emsp;&emsp;&ensp;子进程继承父进程的打开文件表，这意味着子进程也可以访问父进程可以访问的文件。

### 文件创建：具体操作

<div style=" margin: 0 auto; max-width: 40%;">
<img src="%E5%A4%96%E5%AD%98inode%E8%A1%A8.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件删除：具体操作

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 105.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件读写

#### 文件指针

&emsp;&emsp;&ensp;文件指针又叫文件读写位置，存放在文件描述符的表项中，用来标记文件读写起始位置的**逻辑地址**。可以通过特定的系统调用修改文件指针来实现对文件的随机读写。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8-1.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;具体过程：
* 读文件指的是将文件的内容从磁盘中读入内存，写文件的含义是将内存中某块数据写入到磁盘的文件中的某个位置。
&emsp;&emsp;&ensp;文件指针：每次读/写文件会从文件指针的位置读/写 ${len}$ 长度的内容。
&emsp;&emsp;&ensp;而函数的参数中并没有文件指针的存在，**文件指针存在进程级打开文件表之中**（这实现了不同进程之间读取文件的需求不同的要求）。
&emsp;&emsp;&ensp;随着读写操作，文件指针也会自动向后移动。
&emsp;&emsp;&ensp;${buffer}$：${buffer}$ 指示的是内存中用来和磁盘进行数据交互的位置。
&emsp;&emsp;&ensp;${fd}$：读写文件使用的是 ${fd}$。之前打开文件的操作已经返回了 ${fd}$，直接使用 ${fd}$ 即可访问 ${inode}$ 和磁盘中的文件。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 107.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 管道复用文件系统接口

&emsp;&emsp;&ensp;在进程的角度看，管道是一个被打开的文件。此处的 ${f1}$ 和 ${f2}$ 为文件描述符，建立一个管道返回两个文件描述符，分别负责读管道和写管道。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%9C%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%EF%BC%8C%E7%AE%A1%E9%81%93%E6%98%AF%E4%B8%80%E4%B8%AA%E8%A2%AB%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;其他信息中包含对文件类型的判断，若发现文件类型为管道的读/写端，则**调用管道访问函数**。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 110.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;对管道访问权限的释放也使用文件系统的 ${close}$ 接口。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="close%EF%BC%88f1%EF%BC%89.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件保护

&emsp;&emsp;&ensp;文件保护主要包含两层：
&emsp;&emsp;&ensp;第一层：用户打开文件时申请的权限不能超出文件的允许的权限；
&emsp;&emsp;&ensp;第二层：用户对文件的操作不能超出自身打开文件时申请的权限。

#### 第一层保护

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 112.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E6%9D%83%E9%99%90%E7%A7%8D%E7%B1%BB%E4%B8%BA3%EF%BC%8C%E5%88%99%E6%AF%8F%E7%BB%84%E9%9C%80%E8%A6%813%E4%BD%8D%E4%BF%9D%E6%8A%A4.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 第二层保护

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8-2.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8-3.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E8%BF%9B%E7%A8%8B%E7%BA%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8-4.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 文件的逻辑结构

&emsp;&emsp;&ensp;即逻辑文件，即用户视角下的文件。不管是哪种文件，我们的目的都是将关键字 ${key}$ 转化为逻辑地址 ${addr}$。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E7%9B%B4%E6%8E%A5%E6%88%96%E6%95%A3%E5%88%97%E6%96%87%E4%BB%B6.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 无结构文件（流式文件）

&emsp;&emsp;&ensp;无结构文件（流式文件）：以字节（字符流或者基本二进制等）为基本单位的文件，例如字符文件或者二进制文件。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 117.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 有结构文件

&emsp;&emsp;&ensp;有结构文件：文件数据被组织成格式相近的记录，记录作为文件的基本单位，例如目录文件，其基本单位为目录项。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%EF%BC%88%E5%AD%A6%E5%8F%B7%EF%BC%8C%E5%A7%93%E5%90%8D%EF%BC%8C%E6%88%90%E7%BB%A9%EF%BC%8C%E6%8E%92%E5%90%8D%EF%BC%89.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 有结构文件的分类

##### 顺序文件

&emsp;&emsp;&ensp;记录通常定长，且按文件地址位置顺序排布，类似于数据结构中的顺序表。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 119.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

##### 顺序文件的分类

&emsp;&emsp;&ensp;顺序结构：文件中的记录按关键码大小顺序进行排布，可以通过折半查找等方法快速获取对应记录。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 120.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;串结构：文件中的记录随机存放，查找对应记录只能通过顺序查找方式。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 121.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

##### 索引文件

&emsp;&emsp;&ensp;索引文件通常用于记录不定长的有结构文件中，会在文件特定的位置存放一张索引表，索引表中存放了文件的每一条记录的长度以及其在文件中的位置。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 123.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;索引顺序文件：索引顺序文件将顺序文件的记录分成了若干组，每组组内的记录不一定有序，但是组与组之间的记录一定有序，再提供一个索引表指向每组首个记录的地址。例如在一个学校的姓名表中，将首字母为 ${A～Z}$ 的姓名分别分到一个组中，组内姓名随机排布。
&emsp;&emsp;&ensp;当查找姓名“${Rise}$”时，可以先通过二分法找到R开头的姓名“${Rose}$”所在的首地址，再通过顺序检索找到 “${Rise}$”。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 124.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

##### 直接或散列文件

&emsp;&emsp;&ensp;直接或散列文件将对应的记录直接放到其关键码散列值对应的逻辑地址处，即可通过 ${hash}$ 操作直接得到记录的文件逻辑地址。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 125.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 文件实现

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 126.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件分配

&emsp;&emsp;&ensp;面向问题：借助 ${inode}$，文件的逻辑地址如何转化为实际的磁盘物理地址。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E9%80%BB.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 128.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 连续分配

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 129.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;问题:
&emsp;&emsp;&ensp;读取第 ${k}$ 号文件块需要多少次磁盘 ${I/O}$ 操作？
&emsp;&emsp;&ensp;只需要 ${1}$ 次。
&emsp;&emsp;&ensp;如何删除掉文件盘块 ${1}$ 中的记录？
&emsp;&emsp;&ensp;首先要释放文件盘块 ${1}$。然后处理过程类似于 ${ds}$ 中顺序表的删除过程。也可以选择从前往后移动，即先移动盘块 ${0}$，再修改起始块地址。
&emsp;&emsp;&ensp;连续分配的优劣势：
&emsp;&emsp;&ensp;优点：实现简单；存取速度快。
&emsp;&emsp;&ensp;缺点：不适合动态增长；记录插入和删除操作效率低下；外部碎片。

#### 链式分配

##### 隐式链接（若无特别说明，提到链式分配指的是隐式链接）

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 130.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;问题：
&emsp;&emsp;&ensp;读取第 ${k}$ 号文件块需要多少次磁盘 ${I/O}$ 操作？
&emsp;&emsp;&ensp;${k+1}$ 次 ${I/O}$ 操作。因为需要获取文件块 ${0 ～\ (k-1)}$ 中的下一块地址，之后再读取目标磁盘块。

##### 显式链接（FAT）

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 131.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;关于文件分配表 ${FAT}$：
&emsp;&emsp;&ensp;一个文件系统只有一个 ${FAT}$，且存放于内存中，每个文件在修改自己的磁盘块布局时都要修改 ${FAT}$。
&emsp;&emsp;&ensp;${FAT}$ 可以用来标识磁盘中的空闲块，如图所示，一个文件的最后一块用 ${-1}$ 表示，空闲的磁盘块用 ${-2}$ 表示就可以了。
&emsp;&emsp;&ensp;由于 ${FAT}$ 在内存中，因此**读取文件的任何一个逻辑块实际上都仅仅需要一次磁盘访问**，因此显式链式分配是**可以实现随机访问**的。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 132.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 索引分配

&emsp;&emsp;&ensp;在 ${inode}$ 中存放一个索引指针的数组，利用这些索引指针来指示文件所占据的物理磁盘块。

##### 直接索引

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E6%96%87%E4%BB%B6%E6%9C%894%E4%B8%AA%E6%96%87%E4%BB%B6%E5%9D%97%EF%BC%8C%E5%88%86%E5%88%AB.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

##### 间接索引

###### 一级索引

&emsp;&emsp;&ensp;定位需要一次 ${io}$。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="截屏2024-08-27 15.28.14.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="截屏2024-08-27 15.29.38.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;二级、三级以此类推即可。

###### 混合索引

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%81%87%E8%AE%BEinode%E4%B8%AD%E5%8C%85%E5%90%AB10%E4%B8%AA%E7%9B%B4%E6%8E%A5%E7%B4%A2%E5%BC%95%E3%80%811.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 135.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;问题：
&emsp;&emsp;&ensp;假设需要读取文件的 ${100}$ 号文件块？
&emsp;&emsp;&ensp;需要进行 ${3}$ 次磁盘 ${io}$。

#### 对磁盘块操作所需的io次数

&emsp;&emsp;&ensp;当定位到具体的磁盘块后，我们通常对磁盘块有三种操作，分别为读取、修改、覆盖。
&emsp;&emsp;&ensp;读取：若需要读取磁盘块中的某一个或全部数据，则需要将**整个磁盘块从磁盘中读入内存**中，需要一次磁盘 ${I/O}$。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 136.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;修改：若需要将磁盘块中的某个数据修改（其他数据保持不变），则需要先把整个磁盘块读入内存，对读入的磁盘块进行修改，最后把修改后的块整体写回磁盘。**${I/O}$ 次数为二次**。内外存数据交换**必须以磁盘块为基本单位**。
&emsp;&emsp;&ensp;覆盖：对于给定的磁盘块，用内存中给定的整个块的数据直接对其进行覆盖，而不用考虑对其原有数据的保护。例如将磁盘块 ${k}$ 作为空闲盘块分配给文件时，对其的操作就是覆盖，只需要磁盘 ${I/O}$ 一次。
&emsp;&emsp;&ensp;${I/O}$ 例题：

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Pasted Graphic 138.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;第一问：又文件 ${A}$ 共有 ${598}$ 条记录，每个物理块有 ${2}$ 条记录，则文件 ${A}$ 共占用 ${598/2=299}$ 个磁盘块。要将其全部读入内存需要 ${5+299=304}$ 次磁盘 ${I/O}$。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Pasted Graphic 137.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;第二问：第 ${487}$ 条记录在 ${487/2=243}$ 个文件块当中，又因为 ${A}$ 为连续文件，则只需要首地址+逻辑块号即可找到目标记录所在位置。因此只需要一次存取即可获取该记录，所以此时需要 ${5+1}$ 次 ${I/O}$。

## 文件系统外存布局

### 超级块

&emsp;&emsp;&ensp;存放文件系统相关的信息。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 139.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 数据块区域

&emsp;&emsp;&ensp;存放真正文件数据的位置。

<div style=" margin: 0 auto; max-width: 30%;">
<img src="Pasted Graphic 140.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 空闲磁盘块管理

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 141.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;需要考虑的问题：如何实现空闲磁盘块的组织？

#### 空闲表法

&emsp;&emsp;&ensp;在空闲表法中，每一段连续分布的空闲磁盘块被组织成一个空闲区，系统为所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，每个表项包括该空闲区第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列。
&emsp;&emsp;&ensp;类似于内存分配中的动态分区算法，主要适用于文件的连续分配方法。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 142.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 空闲链表法

##### 空闲盘块链

&emsp;&emsp;&ensp;将磁盘上的所有空闲空间，以盘块为单位拉成一条链。当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当的数目的空闲盘块分配给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="%E5%88%86%E9%85%8D%E6%97%B6%EF%BC%9A%E4%BB%8E%E9%93%BE%E9%A6%96%E5%BC%80%E5%A7%8B%E6%91%98%E5%8F%96%E5%AF%B9%E5%BA%94%E6%95%B0%E9%87%8F%E7%9A%84.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

##### 空闲盘区链

&emsp;&emsp;&ensp;将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。在每个盘区上除含有用于指示下一个空闲盘区的指针外，还应有能指明盘区大小（盘块数）的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 144.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 位图

&emsp;&emsp;&ensp;用位图代表空闲数据块列表：${1111111111110011111111011010101101001…}$，${D_i=0}$ 表明数据块 ${i}$ 是空闲，否则，表示已分配。
&emsp;&emsp;&ensp;使用简单但是可能会是一个很大的向量表。
&emsp;&emsp;&ensp;如何分配磁盘块给文件使用？
&emsp;&emsp;&ensp;找到为 ${0}$ 的对应的盘块分配，并把 ${0}$ 改为 ${1}$。
&emsp;&emsp;&ensp;如何回收磁盘块？
&emsp;&emsp;&ensp;找到想要回收的块，将位图中该块的值置为 ${1}$。

#### 成组链接法

&emsp;&emsp;&ensp;空闲盘块链法的缺陷：链过长，进行大量空闲盘块分配时的效率极低。
&emsp;&emsp;&ensp;空闲盘区链法的缺陷：只有存在大量连续的空闲磁盘块时链表才比较短，条件苛刻。
&emsp;&emsp;&ensp;为何不用类似于文件实现中的索引表法？
&emsp;&emsp;&ensp;索引方式空闲磁盘块数目过多，索引表过于庞大，放入内存需要很多次磁盘 ${I/O}$。
&emsp;&emsp;&ensp;一个索引块指向的**所有空闲块均作为一个分组**，每次 ${I/O}$ 操作可以取出一个索引块，从而**获取其所指向的所有空闲块**。此处索引块指向的各盘块不需要连续。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 145.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 146.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;实际上的磁盘块链接块如下图所示，索引块 ${0}$ 的内容置于超级块中，在一开始就被放入内存，每一组磁盘块的第一个盘块作为下一组盘块的索引节点。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 147.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;索引块中除了包含下一分组中的所有磁盘块号，还包含下一分组的盘块数量。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 148.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;每个索引块中的索引均存在数量上限，超过数量上限时需要进行特殊处理。
&emsp;&emsp;&ensp;最后一个分组只有一个索引块，其中记录 ${N=-1}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 149.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;空闲块分配：每次分配索引块均从分组 ${0}$ 中分配。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 150.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;若 ${N=1}$ 后需要继续分配，则将分组 ${1}$ 的索引块（图中的磁盘块 ${18}$）复制到索引块 ${0}$ 中，并将该节点分配出去。
&emsp;&emsp;&ensp;在此步骤之前都没有磁盘 ${I/O}$，只有此时将磁盘块 ${18}$ 的内容读入内存才有磁盘 ${I/O}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 151.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此后，链长 ${-1}$，原先的分组1代替成为了分组 ${0}$，成为下一个被分配的分组。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 152.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;空闲块回收：每次回收到分组 ${0}$ 上，回收工作仅需在索引块 ${0}$ 中添加一个指针指向磁盘块 ${50}$，都不需要磁盘 ${I/O}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 154.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;假设分组上限是 ${5}$ 个空闲块，则如果继续回收？
&emsp;&emsp;&ensp;将新回收的块作为一个新分组的索引，并将索引块 ${0}$ 的信息复制过去，仅需一次 ${I/O}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 155.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此后即可在新的分组 ${0}$ 继续插入了。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 156.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;成组链接法的优势：
&emsp;&emsp;&ensp;分配时：只有在分组 ${0}$ 中的空闲盘块均分配完时，才需要进行 ${I/O}$ 操作。
&emsp;&emsp;&ensp;回收时：只有在分组 ${0}$ 中的空闲盘块数超出上限时，才需要进行 ${I/O}$ 操作。
&emsp;&emsp;&ensp;空闲磁盘块管理与文件分配的区别：
&emsp;&emsp;&ensp;空闲磁盘块**在磁盘当中随意分布的，文件分配是管理文件所占用的磁盘块**。
&emsp;&emsp;&ensp;空闲磁盘块数目远大于一个文件占用的磁盘块数目，因此**并不适合将所有信息调入内存中**，除非进行特殊处理（如位图法，而 ${FAT}$ 只适合小型磁盘块）；
&emsp;&emsp;&ensp;空闲磁盘块的每一块地位相同，进行分配时分配任意位置的磁盘块均可，**并不像文件实现一样具有逻辑上的差异**。

## 磁盘初始化

### 低级（物理）格式化

&emsp;&emsp;&ensp;低级（物理）格式化是将硬盘划分出磁道，再将磁道划分为若干个扇区，每个扇区又划分出标识部分 ${ID}$、间隔区、${GAP}$ 和数据区 ${DATA}$。
&emsp;&emsp;&ensp;由生产厂商做好，无须用户来做。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 157.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 磁盘分区

&emsp;&emsp;&ensp;磁盘分区操作是为磁盘进行逻辑上的再划分，它将**磁盘物理空间划分为多个部分，每个部分作为一个逻辑上独立的磁盘，即为分区**。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Pasted Graphic 158.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 高级（逻辑）格式化

&emsp;&emsp;&ensp;逻辑格式化是**为文件系统运行在磁盘分区上服务的**，在操作系统的文件系统子系统装入内存之前，磁盘分区便完成了逻辑格式化，此后，**文件系统便可以以文件的形式访问磁盘分区上的所有数据**。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 159.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 逻辑格式化的工作

&emsp;&emsp;&ensp;逻辑格式化是**为文件系统服务**的，因此针对不同文件系统的逻辑格式化都是不相同的，但是它们包含着一些共性。**逻辑格式化位于操作系统引导之前，是进行任意文件操作的准备工作**。
&emsp;&emsp;&ensp;与**磁盘分区布局和管理磁盘空间相关的结构**均在逻辑格式化时创建，例如：创建 ${FAT}$ 表；创建超级块。
&emsp;&emsp;&ensp;根目录由逻辑格式化创建：文件系统在未进行任何操作之前就存在根目录，因此它是由逻辑格式化创建的。
&emsp;&emsp;&ensp;与文件系统有关的功能，只要不是文件操作可以做到的，都是逻辑格式化做的。

#### 逻辑格式化与文件系统运行

&emsp;&emsp;&ensp;负责逻辑格式化的程序和使用该逻辑磁盘的文件系统**都了解磁盘的布局方式**，逻辑格式化是**对磁盘进行布局的一方**，而文件系统则是**利用这一布局来访问磁盘文件的一方**。不同的文件系统对应不同的逻辑格式化方法，因此逻辑格式化又称为**文件系统安装**。
&emsp;&emsp;&ensp;思考：在如下图所示的文件系统中如何获取一个空闲磁盘块的物理块号？

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 160.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

## 虚拟文件系统

&emsp;&emsp;&ensp;文件卷：文件卷又名逻辑卷、逻辑盘，磁盘分区等，每个文件卷对应一个文件系统。**磁盘分区是我们建立文件系统的前置条件**。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 161.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;虚拟文件系统：计算机中的设备可能包含多个分区，每个分区对应一种文件系统，但是我们可以把它抽象成一个统一的 ${VFS}$ 接口，用户直接通过 ${VFS}$ 接口进行访问，从而屏蔽了各种文件系统内部的不同细节。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 162.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件系统挂载

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 163.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;${fs1}$ 可以通过以下目录树来访问原 ${fs2}$ 中的文件 

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 164.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件系统的层次结构

<div style=" margin: 0 auto; max-width: 35%;">
<img src="Pasted Graphic 165.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 167.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;磁盘缓存层：文件系统试图读取磁盘块之前先检查该磁盘块是否已经缓存在内存中，若已经缓存，则直接读取内存中缓存的磁盘块，否则，去磁盘中读取。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%AD%98%E5%9C%A8%E5%88%99%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%EF%BC%8C%E4%B8%8D%E5%AD%98%E5%9C%A8-1.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;磁盘驱动层：磁盘缓存层利用磁盘驱动程序封装好的接口来读取所需要的磁盘块，驱动程序通过访问 ${I/O}$ 控制器中的 ${I/O}$ 端口来实现对磁盘的访问。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Pasted Graphic 169.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;物理磁盘层：${I/O}$ 端口中被写入数据后，将**由磁盘控制器转化为对磁盘设备的具体命令**，通过 ${DMA}$ 方式将对应磁盘数据读到给定的内存位置。

#### 内存映射文件

&emsp;&emsp;&ensp;内存映射函数：
&emsp;&emsp;&ensp;函数原型：

```cpp
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset); 
```

&emsp;&emsp;&ensp;文件必须**已经打开**才能进行映射。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 170.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;效果

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 171.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 共享机制

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 172.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 磁盘工作机制和性能参数

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 173.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;盘区地址：三元组（柱面，盘面，扇区）

#### 工作机制

&emsp;&emsp;&ensp;读取或写入时，磁头必须被定位在期望的磁道，并从所期望的盘面和扇区开始。这种机制决定了访问连续的扇区或者磁盘块时访问效率更高。

#### 性能参数

&emsp;&emsp;&ensp;寻道时间：定位到期望的磁道所花费的时间。
&emsp;&emsp;&ensp;旋转延迟：从零扇区开始处到达目的地花费的时间。平均旋转延迟时间=磁盘旋转一周时间的一半
&emsp;&emsp;&ensp;磁盘 ${I/O}$ 传输时间：

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 174.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 20%;">
<img src="Pasted Graphic 175.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 20%;">
<img src="1r =旋转一周的时间.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 20%;">
<img src="截屏2024-08-28 16.04.44.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 磁盘调度算法

&emsp;&emsp;&ensp;${FIFO}$ 算法示例

<div style=" margin: 0 auto; max-width: 50%;">
<img src="122 124.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;最短服务时间优先（${SSTF}$）
&emsp;&emsp;&ensp;选择从磁臂当前位置需要移动最少的 ${I/O}$ 请求；总是选择最短寻道时间。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%88%9D%E5%A7%8B%E7%A3%81%E5%A4%B4%E4%BD%8D%E7%BD%AE%EF%BC%9A53.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;扫描算法（${SCAN}$）
&emsp;&emsp;&ensp;磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道，再调换方向。也称电梯算法（${elevator\quad algorithm}$）

<div style=" margin: 0 auto; max-width: 50%;">
<img src="%E5%88%9D%E5%A7%8B%E7%A3%81%E5%A4%B4%E4%BD%8D%E7%BD%AE%EF%BC%9A53-1.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;循环扫描算法（${C-SCAN}$）
&emsp;&emsp;&ensp;限制了仅在一个方向上扫描；当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行。**磁臂移动到另一端的移动距离也需要计算**。
&emsp;&emsp;&ensp;磁头粘着（${Arm\quad Stickiness}$）现象：${SSTF}$、${SCAN}$ 及 ${C-SCAN}$ 等算法中，可能出现磁头停留在某处不动的情况。

---

## 场景（强化）

### 场景设定

&emsp;&emsp;&ensp;一个磁盘块的大小为 ${1KB}$，其中，${list.db}$ 文件中所有记录的大小总和为 ${102656B}$，一个磁盘块可以容纳两个目录项。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件逻辑结构

&emsp;&emsp;&ensp;**用户视角下**的文件是连续的结构。${list.db}$ 的每条记录都是 ${128B}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-1.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件逻辑结构：顺序文件

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-2.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件逻辑结构：索引文件

&emsp;&emsp;&ensp;每个索引文件在特定位置都会有一张索引表，不用管具体是在什么位置。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-3.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件逻辑结构：直接或散列文件

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-4.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件操作

#### 文件操作：打开文件

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;系统调用接口：

```cpp
int fd=open("root/dir1/dir4/list.db", ...);
```

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-6.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    ...
}
```

&emsp;&emsp;&ensp;通过查询索引表找到 ${inode0}$ 并依据其“物理地址”字段获取 ${root}$ 目录所占用的两个文件块在磁盘中的位置，将其载入内存当中。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-7.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;${root}$ 中存放的均为目录项，即(文件名, 索引节点编号)的二元组。从 ${root}$ 目录中检索文件名为 ${dir1}$ 的目录项。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-8.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;${inode26}$ 被装入内存。需要一次寻找 ${dir4}$ 的目录项。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-9.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此时文件块 ${0}$ 中没有 ${dir4}$ 的目录项，需要再进行一次 ${IO}$ 将文件块 ${2}$ 载入内存。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-10.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-11.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-12.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-13.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-14.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;检索发现 ${list.db}$ 对应文件索引节点 ${inode97}$，将其放入内存。文件打开的第一个步骤完成，接下来将进入下一个步骤：建立与打开文件相关的系统级打开文件表与用户级打开文件表的表项。

<div style=" margin: 0 auto; max-width: 30%;">
<img src="Image-15.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;在系统级打开文件表为该打开文件创建新的表项。此处的缓存地址指向在内存中的 ${inode}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-16.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;在用户级打开文件表为该打开文件创建新的表项。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-17.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;将新表项在**用户级打开文件表中的索引**作为 ${open()}$ 的返回值。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-18.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;若进程 ${P2}$ 打开同样的文件，则 ${P2}$ 的用户级打开文件表中也会生成一个指向相同的系统表项的用户表项，同时系统表项访问计数加 ${1}$。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-19.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-20.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件操作：文件读写

&emsp;&emsp;&ensp;进程 ${P}$ 开始读取 ${list.db}$ 中的相关记录，根据上文我们知道其在文件中的逻辑地址为 ${51458B}$，读取长度为 ${128B}$，我们将记录读入提前准备好的数组 ${buffer}$ 中，其具体操作如下：

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    // 操作a
    int read_len = read(参数1, buffer, 参数3, ...);
}
```

&emsp;&emsp;&ensp;操作 ${a}$ 完成什么功能？
&emsp;&emsp;&ensp;修改 ${fd}$ 对应的表项的文件指针为 ${51458B}$。

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    Iseek(fd,51458,...);    // 一个系统调用，用于修改文件指针。
    int read_len = read(参数1, buffer, 参数3, ...);
}
```

&emsp;&emsp;&ensp;参数 ${1}$ 和参数 ${2}$ 分别是什么数据？
&emsp;&emsp;&ensp;分别为打开文件 ${list.db}$ 的文件描述符和数据读取长度。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-21.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-22.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;文件占用 ${\lceil (102656B/1KB)\rceil=101}$
&emsp;&emsp;&ensp;${read()}$ 会读取文件数据的第 ${[51458B, 51458B+128B)}$ 到内存中的 ${buffer}$ 数组里。
&emsp;&emsp;&ensp;注意：${read()}$ 操作需要检查表项中的权限部分是否允许“读”操作。

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    Iseek(fd,51458,...);    // 一个系统调用，用于修改文件指针。
    int read_len = read(fd, buffer, length=128, ...);
}
```

&emsp;&emsp;&ensp;这部分数据在几号文件块中？
&emsp;&emsp;&ensp;${51458B/1024B=50}$，因此在 ${50}$ 号文件块中。
&emsp;&emsp;&ensp;假设 ${list.db}$ 的文件块 ${50}$ 被放入了以 ${a}$ 为起始地址的内存中请问要进程要读取的文件数据在**内存中**的首地址是多少？读入内核空间还是用户空间？
&emsp;&emsp;&ensp;此时会将该文件块读入**内核空间**。因为文件是以块为单位读入内存的，而读操作的范围是小于等于块的。操作系统并不能将整个块的读取权限都交给用户，所以存入的是内核空间。之后操作系统会再把对应的 ${128B}$ 读入用户空间的 ${buffer}$ 数组里。首地址是 ${51458B\% 1KB=348B}$，起始内存地址为 ${a+348B}$。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-24.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;读入完毕后，${fd}$ 指向的表项的文件指针是多少？
&emsp;&emsp;&ensp;之前已经读到了文件的第 ${51458+128-1}$ 个字节，因此下一个要读的地址为 ${51458+128=51586B}$，即为**文件指针取值**。在用户视角下，存取文件的基本单位是记录，用户要多少记录，操作系统会返回给的就是那个记录。文件系统从磁盘中获取文件就是以块为单位的。

<div style=" margin: 0 auto; max-width: 30%;">
<img src="Image-23.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此时如果继续执行 ${read(fd, buffer, length=128, ...);}$，会读取文件逻辑地址的 ${[51586B, 51586B+128B)}$。
&emsp;&emsp;&ensp;每个进程均依据各自的文件指针独立的读取文件数据，互不干扰。

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    Iseek(fd,51458,...);    // 一个系统调用，用于修改文件指针。
    int read_len = read(fd, buffer, length=128, ...);
}
P2() {
    int fd2=open("root/dir1/dir4/list.db", ...);
    int read_len = read(fd2, buffer, length=128, ...);
}
```

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-25.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件操作：文件关闭

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    Iseek(fd,51458,...);    // 一个系统调用，用于修改文件指针。
    int read_len = read(fd, buffer, length=128, ...);
    close(fd);
}
P2() {
    int fd2=open("root/dir1/dir4/list.db", ...);
    int read_len = read(fd2, buffer, length=128, ...);
}
```

&emsp;&emsp;&ensp;${p}$ 进程关闭 ${fd}$ 指向的文件。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-26.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-27.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

```cpp
P() {
    int fd=open("root/dir1/dir4/list.db", ...);
    Iseek(fd,51458,...);    // 一个系统调用，用于修改文件指针。
    int read_len = read(fd, buffer, length=128, ...);
    close(fd);
}
P2() {
    int fd2=open("root/dir1/dir4/list.db", ...);
    int read_len = read(fd2, buffer, length=128, ...);
    close(fd2);
}
```

&emsp;&emsp;&ensp;${p2}$ 进程关闭 ${fd2}$ 指向的文件。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-28.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-29.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;系统级打开文件表中表项引用计数减为 ${0}$，同样移除。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-30.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件的物理分配

&emsp;&emsp;&ensp;如何利用文件元数据中的物理 地址字段确定 ${list.db}$ 的文件块 ${50}$ 在磁盘中的物理位置？

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-31.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

#### 文件分配：连续分配方式

&emsp;&emsp;&ensp;若文件分配方式采用连续分配方式，则物理地址字段中保存什么内容？
&emsp;&emsp;&ensp;起始块号；文件块数。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-32.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;读取文件块 ${50}$ 中的数据需要几次磁盘 ${I/O}$？修改文件块 ${50}$ 中的数据需要几次磁盘 ${I/O}$？
&emsp;&emsp;&ensp;${1}$ 次，直接读入（起始块号 ${+50}$）号物理块即可；${2}$ 次，一次读入到内存中修改，一次写回。

#### 文件分配：链式分配方式

&emsp;&emsp;&ensp;若文件分配方式采用链式分配方式，则物理地址字段中保存什么内容？
&emsp;&emsp;&ensp;起始块地址

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-33.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;读取**文件块 ${50}$ 中的数据**需要几次磁盘 ${I/O}$？修改文件块 ${50}$ 中的数据需要几次磁盘 ${I/O}$?
&emsp;&emsp;&ensp;${51}$ 次，分别读取文件块 ${0\~\ 49}$ 中的指针，找到块 ${50}$,再读取块 ${50}$；${52}$ 次，用 ${50}$ 次 ${I/O}$ 找到文件块 ${50}$，读入内存 ${1}$ 次 ${I/O}$，修改后写回磁盘 ${1}$ 次 ${I/O}$。

#### 文件分配：FAT方式

&emsp;&emsp;&ensp;若文件分配方式采用 ${FAT}$ 方式（**显式链式方式**），则物理地址字段中保存什么内容？

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-34.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;修改文件块 ${50}$ 中的数据需要几次磁盘 ${I/O}$？
&emsp;&emsp;&ensp;${2}$ 次，因此找到文件块 ${50}$ 不需要磁盘 ${I/O}$，只需要查询内存中的 ${FAT}$ 表。

#### 文件分配：混合索引分配方式

&emsp;&emsp;&ensp;若文件分配采用**混合索引**方式，文件元数据中包含 ${10}$ 个直接索引，${1}$ 个一级索引和 ${1}$ 个二级索引，且每个地址项的大小为 ${4B}$。
&emsp;&emsp;&ensp;一个一级索引和一个二级索引分别可以管理多少个文件块？
&emsp;&emsp;&ensp;一个索引块包含 ${1KB/4B=256}$ 个地址项，因此1级索引管理 ${256}$ 个文件块，${2}$ 级索引管理 ${256^2}$ 个文件块。
&emsp;&emsp;&ensp;如何访问到 ${list.db}$ 的文件块 ${50}$ 中的数据？

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-35.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;可以判断出文件块 ${50}$ 由 ${1}$ 级索引管理， 需要 ${2}$ 次磁盘 ${I/O}$ 才能将其读取。具体读取方法详见基础课。
&emsp;&emsp;&ensp;该文件一共占用了几个数据块和索引块？
&emsp;&emsp;&ensp;该文件共用数据块 ${101}$ 个，只用到了 ${1}$ 级索引对应的索引块，所以共用了 ${1}$ 个索引块，${101}$ 个数据块。
&emsp;&emsp;&ensp;如果该文件大小一共为 ${528}$ 块，那么一共使用了几个索引块？
&emsp;&emsp;&ensp;需要用到 ${1}$ 级索引指向的索引块，${2}$ 级索引指向的索引块以及该索引块指向的索引块的前 ${2}$ 个，因此共 ${1+1+2=4}$ 个索引块。

### 文件缓存

&emsp;&emsp;&ensp;磁盘缓存区在用户空间还是内核空间？
&emsp;&emsp;&ensp;内核空间！因为磁盘缓存是给所有进程共同使用的。
&emsp;&emsp;&ensp;缓存区缓存的块除了读入的磁盘块的信息，**还需要存入哪些信息**？
&emsp;&emsp;&ensp;需要记录该块**在磁盘中的物理位置**，即在磁盘中的物理块号。（实际上还有**逻辑设备号**）
&emsp;&emsp;&ensp;在如图所示的读文件操作中，进程是否会获取完整的文件块 ${50}$ 中的信息？为什么？

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-36.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;不会，文件块只会读入内核的缓存区中，再由操作系统读取用户请求读取的部分到用户 ${buffer}$ 中。
&emsp;&emsp;&ensp;若磁盘传送**采取 ${DMA}$ 方式**，那么 ${P}$ 进程何时被阻塞？${P}$ 被唤醒后**数据是否已经写入磁盘缓存**？
&emsp;&emsp;&ensp;${P}$ 发起 ${IO}$ 等待输入时候被阻塞。等到 ${DMA}$ 传送完成后，发起 ${DMA}$ 中断，${P}$ 进程重新掌控后，数据已经写入磁盘缓存。

### 文件系统布局

&emsp;&emsp;&ensp;该图展示了超级块 ${superblock}$ 的各个字段及其含义，在每个字段上方标注了其具体取值。该文件系统磁盘块的大小为 ${1KB}$，一个索引节点（${inode}$）的大小为 ${4B}$。 

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-37.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;${superblock}$ 中的信息是何时被写入的？什么时候被放入内存？
&emsp;&emsp;&ensp;逻辑格式化；多文件系统下是在**文件系统挂载**时候放入内存；单文件系统下是在**操作系统初始化（开机也行）时候**放入内存。
&emsp;&emsp;&ensp;校验区的作用是什么？
&emsp;&emsp;&ensp;区分文件系统类型，检测文件系统合法性。
&emsp;&emsp;&ensp;该文件系统最多可以存在多少个文件？
&emsp;&emsp;&ensp;一个文件对应一个 ${inode}$，因此可以依据文件系统中最多可以存在的 ${inode}$ 数来判断文件数的最大值。一个磁盘块最多可以装入 ${1KB/4B=256}$ 个索引节点，索引节点表共占 ${15}$ 块，因此文件系统最多可以存在 ${256*15=3840}$ 个文件。
&emsp;&emsp;&ensp;若不考虑磁盘容量，数据区最多可以存在多少个磁盘块？
&emsp;&emsp;&ensp;数据区磁盘块由 ${bitmap}$ 来管理，${bitmap}$ 中的 ${1}$ 位代表一个磁盘块，而 ${bitmap}$ 共有 ${8*1024*12=98304bit}$，所以数据区最多有 ${98304bit}$ 个磁盘块。
&emsp;&emsp;&ensp;若 ${list.db}$ 的 ${inode}$ 编号是 ${326}$，则其 ${inode}$ 保存在物理磁盘块的几号盘块（从 ${0}$ 开始计数）？它是该盘块中保存的几号 ${inode}$？
&emsp;&emsp;&ensp;一个盘块可以存放 ${256}$ 个 ${inode}$，而 ${326/256=1}$，${326\% 256=70}$，所以 ${list.db}$ 的 ${inode}$ 存放在 ${3+1=4}$ 号物理磁盘块中，是本盘块中的 ${70}$ 号 ${inode}$。

### 文件操作：空闲磁盘块分配

&emsp;&emsp;&ensp;用户对 ${list.db}$ 进行写入操作，并且在它的末端一直写入记录，知道分配给该文件的最后一个磁盘块都被写满了，此后用户继续写入，会发生什么情况？
&emsp;&emsp;&ensp;文件系统分配一个空闲的磁盘块给 ${list.db}$ 使用。
&emsp;&emsp;&ensp;如果文件分配采用直接索引分配的方法，会对文件元数据进行什么操作？
&emsp;&emsp;&ensp;会将第一个之前未使用的索引指向新分配的磁盘块，也就是修改文件元数据的索引。
&emsp;&emsp;&ensp;若磁盘空闲空间管理使用位图法，如何分配一个空闲的磁盘块给文件？
&emsp;&emsp;&ensp;找到 ${bitmap}$ 中一个取值为 ${0}$ 的位，将其置为 ${1}$，并将它所代表的那个磁盘块分配给文件使用。
&emsp;&emsp;&ensp;若管理空闲磁盘块的方法是成组链接法，且 ${0}$ 号分组（即首个分组）中仅剩唯一一个索引块，则**进行一次空闲盘块分配后，各 分组和内存中的索引块会发生哪些变化**?
&emsp;&emsp;&ensp;索引块 ${0}$ 的内容**置于超级块中**，常驻内存，每一组磁盘块的**第一个盘块作为下一组盘块的索引节点**。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-38.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;每次分配索引块均从分组 ${0}$ 中分配。若 ${N=1}$ 后需要继续分配，则将分组 ${1}$ 的索引块（图中的磁盘块 ${18}$）复制到索引块 ${0}$ 中，并将该节点分配出去。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-39.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此后，链长 ${-1}$，原先的分组 ${1}$ 代替成为了分组 ${0}$，成为下一个被分配的分组。

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-40.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;假设分组上限是 ${5}$ 个空闲块，则如果继续回收？
&emsp;&emsp;&ensp;将新回收的块作为一个新分组的索引，并将索引块 ${0}$ 的信息复制过去，仅需一次 ${I/O}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 155.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;此后即可在新的分组 ${0}$ 继续插入了。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Pasted Graphic 156.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;若管理空闲磁盘块的方法是成组链接法，且 ${0}$ 号分组（即首个分组）中仅剩唯一一个索引块，则**进行一次空闲盘块分配后，各分组和内存中的索引块会发生哪些变化**？
&emsp;&emsp;&ensp;分组 ${0}$ 中的索引块内容将被复制到超级块中，并将**索引块分配给文件使用**。

### 文件操作：文件删除

&emsp;&emsp;&ensp;进程 ${P}$ 调用接口 ${delete("root/dir1/dir4/list.db", ...)}$ 进行对 ${list.db}$ 文件的删除。
&emsp;&emsp;&ensp;${list.db}$ 在磁盘中的文件实体一定会被全部清空吗？为什么？

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-41.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;不一定！删除操作只会让 ${list.db}$ 对应的 ${inode}$ 的链接计数减 ${1}$，**只有链接计数归零时，才会在磁盘中彻底清空该文件所占的所有空间**。
&emsp;&emsp;&ensp;若磁盘空闲空间管理使用位图法，如何将文件的某个磁盘块释放？
&emsp;&emsp;&ensp;直接将位图的对应比特位置 ${0}$ 即可。

### 文件共享：软链接与硬链接

&emsp;&emsp;&ensp;注意：**软链接与硬链接均是对某一个目录项的拷贝，自身也是目录项**。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-43.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;由于软链接是创建一个新的 ${inode}$ 节点和新文件，该文件的信息是目录项 ${f1}$（也就是目标原文件）的绝对路径，所以并不会使得 ${inode\quad m}$ 的链接计数 ${+1}$。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-44.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;如果删除原文件，则会使得软链接失效，硬链接依旧正常使用。因为软链接是依据原文件也就是目录项 ${f1}$ 的绝对路径来实现的，所以会访问失败。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-45.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;若此时在创建一个绝对路径为 ${root/x/y}$ 的新建目录项 ${f3}$，则此时软链接恢复正常访问，不过访问的文件变成了新建目录项 ${f3}$ 所指向的文件。

<div style=" margin: 0 auto; max-width: 60%;">
<img src="Image-46.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;删除 ${list.db}$ 后，文件系统变成了如下情况：

<div style=" margin: 0 auto; max-width: 50%;">
<img src="Image-42.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;建立 ${root/dir1/a.txt}$ 的硬链接 ${root/dir1/dir4/01.txt}$。建立硬链接的过程需要**读取 ${a.txt}$ 的 ${inode}$，并修改其链接计数后写入磁盘**。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-47.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;建立 ${root/dir1/a.txt}$ 的软链接 ${root/dir1/dir4/02.txt}$。建立软链接的过程不需要获取 ${a.txt}$ 的 ${inode}$，只需要获取其绝对路径即可。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-48.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 文件系统层次结构

&emsp;&emsp;&ensp;如图所示，我们将前文所分析的文件系统（记为 ${fs2}$）挂载到了另一文件系统（记为 ${fs1}$）的目录 ${dir6}$ 下。同时用户发出 ${open}$ 和读取 ${list.db}$ 记录的命令，访问路径为 ${root/dir5/dir6/dir1/dir4/list.db}$。

<div style=" margin: 0 auto; max-width: 40%;">
<img src="Image-49.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;对于访问 ${list.db}$ 中某一记录的全过程，请将某一具体操作与其所对应的文件系统层次连线。

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-51.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### SPOOLing假脱机技术

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-52.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-53.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-54.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

### 磁盘

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-55.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

&emsp;&emsp;&ensp;磁盘访问时间：主要耗时操作为寻道。当访问连续扇区时，由于连续扇区在同一个磁道上，因此不需要再次寻道，因此性能较高。
&emsp;&emsp;&ensp;读取或写入时，磁头必须被定位在**期望的磁道**，并从**所期望的柱面和扇区**的开始。
&emsp;&emsp;&ensp;**寻道时间**：定位到期望的磁道所花费的时间。
&emsp;&emsp;&ensp;**旋转延迟**：从零扇区开始处到达目的地花费的时间
&emsp;&emsp;&ensp;**平均旋转延迟时间=磁盘旋转一周时间的一半**。
&emsp;&emsp;&ensp;**饥饿现象**：
&emsp;&emsp;&ensp;${FIFO}$：只要先发出请求，一定会先被应答，因此不饥饿。
&emsp;&emsp;&ensp;${SCAN}$：此类电梯类算法，想象一下如果电梯在三楼的时候门外总有人在三楼按键，是否很久不会响应别的楼层的服务？

### RAID

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-56.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-57.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-58.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-59.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-60.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>

<div style=" margin: 0 auto; max-width: 70%;">
<img src="Image-62.png" alt="Alt text" style="margin-top: 0; margin-bottom: 10px;" align="center">
</div>
